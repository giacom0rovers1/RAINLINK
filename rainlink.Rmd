---
title: "RAINLINK Notebook"
output: html_notebook
---
The RAINLINK package. Retrieval algorithm for rainfall mapping from microwave links
in a cellular communication network.

Version 1.14
Copyright (C) 2019 Aart Overeem

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.

Note that it is not necessarily a problem if a function argument is not supplied to the function. If the
function argument is not used, then there is no problem. Only be aware that you should use e.g.
MaxFrequency=MaxFrequency. I.e. if you only supply MaxFrequency and the function argument before
MaxFrequency is missing, than the function will not execute properly.


# 0. Load R libraries, parameter values, and other settings.
This also loads the RAINLINK package.           
```{r Setup}
rm(list = ls())
source("Config.R") 
```

# 1. PreprocessingMinMaxRSL

```{r Data loading}

# Load data:
load("data/Linkdata_vodafone2016.RData")
summary(Linkdata)

# Add column with polarization if this column is not supplied in the link data:
if ("Polarization" %in% names(Linkdata)==FALSE)
{
  Linkdata$Polarization <- rep(NA,nrow(Linkdata))
}
```

When no information on polarization is provided, the above code creates a column of NA for Polarization. In the function "RainRetrievalMinMaxRSL.R" links with
NA values for polarization are processed with a & b values determined for vertically polarized signals.
If information on polarization of links is available, use H for horizontally polarized & V for vertically polarized in Linkdata$Polarization.
H, V & NA may occur in the same Linkdata file.


```{r Preprocessing}
# Run R function:
StartTime <- proc.time()

DataPreprocessed <- PreprocessingMinMaxRSL(Data=Linkdata,
                                           MaxFrequency=MaxFrequency,
                                           MinFrequency=MinFrequency,
                                           verbose=TRUE)

cat(sprintf("Finished. (%.1f seconds)\n",round((proc.time()-StartTime)[3],digits=1))) # ~ 360 seconds

summary(DataPreprocessed)

```


# 2. WetDryNearbyLinkApMinMaxRSL

```{r Classification}
# Run R function:	
StartTime <- proc.time()

WetDry <- WetDryNearbyLinkApMinMaxRSL(Data=DataPreprocessed,
                                      CoorSystemInputData=NULL, 
                                      MinHoursPmin=MinHoursPmin,
                                      PeriodHoursPmin=PeriodHoursPmin,
                                      Radius=Radius,
                                      Step8=Step8, 
                                      ThresholdMedian=ThresholdMedian,
                                      ThresholdMedianL=ThresholdMedianL,
                                      ThresholdNumberLinks=ThresholdNumberLinks, 
                                      ThresholdWetDry=ThresholdWetDry)

cat(sprintf("Finished. (%.1f seconds)\n",round((proc.time()-StartTime)[3],digits=1)))  # ~ 3100 seconds

summary(WetDry)
```

# 3. RefLevelMinMaxRSL

```{r Reference level}
# Run R function:
StartTime <- proc.time()

Pref <- RefLevelMinMaxRSL(Data=DataPreprocessed,
                          Dry=WetDry$Dry,
                          HoursRefLevel=HoursRefLevel,
                          PeriodHoursRefLevel=PeriodHoursRefLevel)

cat(sprintf("Finished. (%.1f seconds)\n",round((proc.time()-StartTime)[3],digits=1))) # ~ 5610 seconds

summary(Pref)
```

# 4. OutlierFilterMinMax
```{r Outliers filter}
# Run R function:
DataOutlierFiltered <- OutlierFilterMinMaxRSL(Data=DataPreprocessed,
                                              F=WetDry$F,
                                              FilterThreshold=FilterThreshold)

summary(DataOutlierFiltered)
```

# 5. CorrectMinMaxRSL

```{r Corrected powers}
# Run R function:
Pcor <- CorrectMinMaxRSL(Data=DataOutlierFiltered,
                         Dry=WetDry$Dry,
                         Pref=Pref)

summary(Pcor)
```


# 6. RainRetrievalMinMaxRSL

```{r Rain retrival}
kRPowerLawDataH <- read.table(FileRainRetrHorizontal)
colnames(kRPowerLawDataH) <- c("f", "a", "b")

kRPowerLawDataV <- read.table(FileRainRetrVertical)
colnames(kRPowerLawDataV) <- c("f", "a", "b")


# Run R function:
StartTime <- proc.time()

Rmean <- RainRetrievalMinMaxRSL(Aa=Aa,
                                alpha=alpha,
                                Data=DataOutlierFiltered,
                                kRPowerLawDataH=kRPowerLawDataH,
                                kRPowerLawDataV=kRPowerLawDataV,
                                PmaxCor=Pcor$PmaxCor,
                                PminCor=Pcor$PminCor,
                                Pref=Pref)

cat(sprintf("Finished. (%.1f seconds)\n",round((proc.time()-StartTime)[3],digits=1))) # ~ 20 seconds

summary(Rmean)
hist(log(Rmean))
```


# Write path-average rainfall data to files:


```{r Save to RData}
ID <- unique(DataPreprocessed$ID)
t <- sort(unique(DataPreprocessed$DateTime))
t_sec <- as.numeric(as.POSIXct(as.character(t), format = "%Y%m%d%H%M"))
dt <- min(diff(t_sec))
save(list=ls(), file = "Cmldata_ER2016.RData")

## merge in a single dataset for analyses
CmlRainfall                   <- DataPreprocessed
CmlRainfall$Pref              <- Pref
CmlRainfall$PminCor           <- Pcor$PminCor
CmlRainfall$PmaxCor           <- Pcor$PmaxCor
CmlRainfall$DryClass          <- WetDry$Dry
CmlRainfall$RainfallMeanInt   <- Rmean
CmlRainfall$RainfallDepthPath <- Rmean * dt / 3600

save(CmlRainfall, file = "CmlRainfall_ER2016.RData")
```


```{r Save to file}
## slow write-to-file, use write_delim() instead
ToFile = F
if (ToFile)
{	
  # Location of output link data:
  FolderRainEstimates <- paste("LinkPathRainDepths",TIMESTEP,"min",sep="")
  
  # Create directory for output files:
  if(!dir.exists(FolderRainEstimates)){ dir.create(FolderRainEstimates) }
  
  # Write output to file
  
  for (i in 1 : length(t))
  {
    ind <- which(DataPreprocessed$DateTime == t[i])
    int_data <- data.frame(ID = DataPreprocessed$ID[ind], 
                           RainfallDepthPath = Rmean[ind] * dt / 3600, 
                           PathLength = DataPreprocessed$PathLength[ind], 
                           XStart = DataPreprocessed$XStart[ind], 
                           YStart = DataPreprocessed$YStart[ind], 
                           XEnd = DataPreprocessed$XEnd[ind], 
                           YEnd = DataPreprocessed$YEnd[ind], 
                           IntervalNumber = rep(i, length(ind)), 
                           Frequency = DataPreprocessed$Frequency[ind])
    
    Filename <- paste(FolderRainEstimates, "/linkdata_", t[i], ".dat", sep="")
    write.table(int_data, Filename, row.names = FALSE, col.names = TRUE, append = FALSE, quote = FALSE)
  }
}
```
Note that the output files contain rainfall depths (mm). If these data are to be used for the interpolation, they must first be read ("Interpolation.R" does not read these files).
Using the data for "Interpolation.R" requires a conversion from rainfall depth (mm) to rainfall intensity (mm/h).


# 7. Interpolation
Interpolation will be performed for hourly accumulated rainfall, so cumulative sums have to be performed
```{r}
# load("CmlRainfall_ER2016.RData")

# Compute hourly accumulated rainfall as sum of the 15min rainfall depths
accu1hr <- function(CmlRainfall, TIMESTEP){
  frac <- 60/TIMESTEP
  dts  <- sort(unique(CmlRainfall$DateTime))
  totdts <- length(dts)
  
  CmlHourlyData <- data.frame()
  hourlydepth   <- 0
  count         <- 0

  StartTime <- proc.time()
  
  for(seldt in dts){                         # Ciclo sui TIMESTEP
    bool1 <- CmlRainfall$DateTime == seldt
    ids   <- unique(CmlRainfall$ID[bool1])
    numdts <- which(dts == seldt)
    
    for(selid in ids){                       # Ciclo sugli ID
      bool2 <- CmlRainfall$ID == selid
      
      j <- which(bool1 & bool2)
      stopifnot(length(j) <= 1)              # Verifico univocitÃ 
      
      depth <- CmlRainfall$RainfallDepthPath[j]
      if(length(j) == 0 ){
        depth <- NA
      }
      
      hourlydepth <- hourlydepth + depth
      count       <- count + 1
      
      if(substr(seldt,11,12)=='00'          # Cerco le ore intere
         & numdts > frac - 1                # Attendo che sia passata almeno la prima ora
         & count == frac                    # Ho tutte le 4 misure dell'ora
         & length(j) != 0){                 # L'ora esiste per il link selezionato
        CmlHourlyData_row <- cbind(CmlRainfall[j,
                                               c("Frequency", "PathLength",  "XStart", 
                                                 "YStart", "XEnd", "YEnd", "Label", 
                                                 "Polarization", "Direction",  "ID")],
                                   DateTime = seldt,
                                   HourlyRainfallDepth = hourlydepth)
        
        CmlHourlyData <- rbind(CmlHourlyData, CmlHourlyData_row)
        
        hourlydepth <- 0
        count       <- 0
      }
      
      if(count > frac){        # in caso di errore (ad esempio per ora piena mancante)
        hourlydepth <- depth   # riparto con la somma delle accumulate
        count       <- 1       # come se fosse il primo intervallo
      } 
      
    }
    elapsed_t <- round((proc.time()-StartTime)[3],digits=1
    remaining_t <- elapsed_t
    cat(sprintf("\r%d of %d , remaining: %f", numdts, totdts, elapsed_t/numdts*(totdts-numdts)))

    
  }
  return(CmlHourlyData)
}


CmlHourlyData <- accu1hr(CmlRainfall = CmlRainfall, #[200000:300000,], # evento 3 marzo
                         TIMESTEP = TIMESTEP)
summary(CmlHourlyData)
# plot(CmlHourlyData$DateTime, CmlHourlyData$HourlyRainfallDepth)

save(CmlHourlyData, file = "HourlyRainfall_ER2016.RData")

```


Interpolation over the grid
```{r}
# load("HourlyRainfall_ER2016.RData")

# Read grid onto which data are interpolated
RainGrid <- read.table(FileGrid, header = TRUE, sep=",")

# # Location of output link data:
# FolderRainMaps <- "HourlyRainMaps"

# Run R function:
StartTime <- proc.time()

RainFields <- Interpolation(Data = CmlHourlyData,
                            CoorSystemInputData = NULL,
                            idp = idp,
                            IntpMethod = IntpMethod,
                            nmax = nmax,
                            NUGGET = NUGGET,
                            RANGE = RANGE,
                            SILL = SILL,
                            Variogram = Variogram,
                            RainGrid = RainGrid,
                            Rmean = CmlHourlyData$HourlyRainfallDepth,
                            OutputDir = NULL)  # FolderRainMaps

cat(sprintf("Finished. (%.1f seconds)\n",round((proc.time()-StartTime)[3],digits=1)))


```

